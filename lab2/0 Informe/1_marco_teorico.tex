\newpage

\section{Marco Teórico}

\subsection{Componentes y fundamentos del sistema}

\subsubsection{Microcontrolador ATmega328P / Arduino UNO}

El ATmega328P es un microcontrolador de 8 bits con arquitectura AVR, reloj típico de 16~MHz, memoria \textit{Flash} (programa), SRAM (datos) y EEPROM (no volátil). Dispone de temporizadores de 8 y 16~bits, puertos GPIO digitales, conversores A/D y periféricos de comunicación (UART, TWI/I\textsuperscript{2}C, SPI). En este laboratorio se utilizó montado sobre la plataforma Arduino~UNO, aprovechando su circuito de alimentación, cristal de 16~MHz y acceso conveniente a pines de E/S \cite{atmega328p_datasheet}.

\subsubsection{Señales PWM y temporización}

La modulación por ancho de pulso (PWM) se empleó para dos fines: (i) generación de señales acústicas en el piano (variación de frecuencia/periodo mediante temporizadores), y (ii) control de posición de servomotores (variación de ciclo útil dentro de un periodo fijo). La obtención de frecuencias precisas se realizó configurando los temporizadores del ATmega328P en modos compatibles con la resolución requerida \cite{atmega328p_datasheet}.

\subsubsection{Indicadores: LEDs y buzzer piezoeléctrico}

Se utilizaron LEDs como señalización visual de estados (éxito, error, bloqueo) y un buzzer piezoeléctrico pasivo para retroalimentación acústica. El buzzer pasivo requiere una señal conmutada (proporcionada por el microcontrolador), a diferencia del activo que integra su propio oscilador. En el piano se aprovechó PWM para tonos audibles; en la cerradura se usaron patrones de \textit{beeps} cortos/largos para codificar eventos \cite{buzzer_emx7t05sp_datasheet}.

\subsubsection{Pantalla LCD 16×2 con interfaz I\textsuperscript{2}C (PCF8574)}

Para visualización se integró un LCD 16×2 comandado en modo 4 bits mediante un \textit{backpack} basado en el expansor de E/S PCF8574. El microcontrolador opera como maestro TWI/I\textsuperscript{2}C y escribe comandos/datos en el expansor, reduciendo el número de pines necesarios y simplificando el cableado \cite{lcd_16x2_i2c_datasheet}.

\subsubsection{Teclado matricial 4×4}

El ingreso de datos en la cerradura se realizó con un teclado 4×4 escaneado por filas/columnas: se activa cada fila y se leen las columnas con \textit{pull-up} interno. Se aplicó \textit{debouncing} por software con retardos cortos y verificación del estado estable, mapeando (fila,columna) a caracteres (\texttt{0–9}, \texttt{A–D}, \texttt{*}, \texttt{\#}) \cite{keypad_4x4_okystar}.

\subsubsection{Memoria EEPROM interna}

El PIN de la cerradura se almacenó en EEPROM para persistencia sin energía. Se validó longitud y contenido al arranque, inicializando un valor por defecto cuando fuera necesario. Las rutinas de escritura/actualización minimizan el desgaste por ciclos de borrado/escritura \cite{atmega328p_datasheet}.

\subsubsection{Servomotor (modelo SG90)}

Se empleó un servomotor de rotación limitada (aprox. \(0^{\circ}\)–\(180^{\circ}\)) controlado por impulsos de \(1\text{–}2\,\mathrm{ms}\) dentro de un período de \(20\,\mathrm{ms}\) (\(50\,\mathrm{Hz}\)). El ángulo se define por el ancho del pulso: valores cercanos a \(1\,\mathrm{ms}\), \(1.5\,\mathrm{ms}\) y \(2\,\mathrm{ms}\) corresponden típicamente a los extremos e intermedio del recorrido, respectivamente. En el laboratorio se utilizó el modelo SG90, cuyas especificaciones eléctricas y mecánicas se tomaron de su hoja de datos \cite{servo_sg90_datasheet}.

\subsubsection{Motores paso a paso (Plotter)}

Para el \textit{plotter XY} se consideró el control de motores paso a paso, caracterizados por su avance angular discreto. El movimiento se obtiene excitando las bobinas según secuencias (\textit{full-/half-step}, microstepping), coordinadas temporalmente por el microcontrolador. La temporización precisa es clave para mantener torque y evitar pérdida de pasos.

\subsubsection{Sensor LDR (fotoresistencia)}

El LDR presenta una resistencia inversamente proporcional a la iluminación incidente, lo que permite sensar luminosidad con un divisor resistivo y lectura A/D. En el selector de color se empleó como señal de realimentación para posicionar el servomotor hacia la fuente de luz predominante \cite{ldr_datasheet}.

\subsubsection{Comunicación UART y \textit{debouncing}}

La UART se utilizó para emitir mensajes de diagnóstico y recibir comandos (por ejemplo, selección de melodías en el piano). Para entradas digitales provenientes de pulsadores y teclado se aplicó \textit{debouncing} por software mediante retardos y verificación consecutiva del estado estable, técnica suficiente dada la baja tasa de eventos del sistema \cite{atmega328p_datasheet}.


\subsection{Piano}

El piano se basa en el microcontrolador ATmega328P, encargado de leer las entradas digitales provenientes de pulsadores y generar las notas musicales correspondientes a través de un buzzer piezoeléctrico. 
Para la síntesis de sonido, se hace uso de señales de modulación por ancho de pulso (PWM), configuradas mediante los temporizadores internos del microcontrolador, permitiendo así obtener frecuencias precisas asociadas a cada nota musical.

En términos acústicos, cada nota musical se corresponde con una frecuencia específica medida en hertzios (Hz), donde un incremento de una octava implica duplicar la frecuencia base. 
Por ejemplo, la nota La de la cuarta octava tiene una frecuencia de 440~Hz, mientras que en la quinta octava alcanza los 880~Hz. 
Esta relación logarítmica entre nota y frecuencia permite reproducir escalas musicales de manera controlada mediante la variación del período de la señal PWM.

El sistema implementa un conjunto de 12 pulsadores, cada uno asignado a una nota de la escala cromática (Do, Do\#, Re, Re\#, Mi, Fa, Fa\#, Sol, Sol\#, La, La\#, Si). 
Además, se integran dos pulsadores adicionales para modificar la octava activa, lo que amplía la capacidad tonal del instrumento sin aumentar significativamente el número de entradas físicas.

El buzzer piezoeléctrico utilizado actúa como transductor electroacústico, recibiendo la señal PWM generada por el ATmega328P y transformándola en vibraciones audibles. 
El uso de resistencias pull-up internas en los pines de entrada digital simplifica el cableado, evitando la necesidad de resistencias externas para los pulsadores.

Por otra parte, la inclusión de la comunicación serial mediante UART (Universal Asynchronous Receiver-Transmitter) permite la selección de canciones predefinidas almacenadas en memoria, 
además de ofrecer la posibilidad de enviar mensajes informativos hacia un terminal externo. 
De esta forma, el sistema no solo funciona como piano manual, sino también como reproductor automático de melodías programadas.

En cuanto al rango tonal, se implementaron las octavas 4 a 7, dado que en la práctica el buzzer presentaba limitaciones físicas en su rango de respuesta. 
Al reproducir frecuencias inferiores a la cuarta octava, el sonido resultaba monótono e indistinguible, mientras que por encima de la séptima octava el transductor no lograba generar vibración audible. 
De esta manera, el sistema cubre el rango más perceptible y estable para este tipo de actuadores.

En la sección de anexos, dentro de tablas complementarias~\ref{tab:notas_piano}, 
se detalla la correspondencia entre las notas musicales y sus frecuencias asociadas, 
así como el índice utilizado en el arreglo de notas dentro del código fuente del proyecto.

En resumen, el piano implementado combina técnicas de generación de señales mediante modulación por ancho de pulso (PWM) con el control secuencial de entradas digitales, demostrando la capacidad del microcontrolador ATmega328P para integrar procesos de adquisición, procesamiento y salida de información en tiempo real, propios de un sistema embebido interactivo.

\subsection{Cerradura electrónica}

La cerradura digital implementada se basa en el microcontrolador ATmega328P y combina adquisición de entradas, procesamiento secuencial y señalización al usuario para validar un PIN de acceso. El sistema integra un teclado matricial 4×4 como interfaz de ingreso, una pantalla LCD 16×2 con interfaz I\textsuperscript{2}C para retroalimentación, y elementos de salida (LEDs y buzzer) para confirmar eventos y estados del sistema. El PIN se almacena de manera no volátil en la memoria EEPROM interna del microcontrolador, lo que permite conservar la configuración aun sin alimentación \cite{atmega328p_datasheet}.

\subsubsection{Ingreso por teclado matricial 4×4}
El teclado se organiza en una matriz de cuatro filas y cuatro columnas. La lectura se realiza mediante \textit{escaneo por filas}: el firmware activa secuencialmente cada fila (lógica baja) y, en cada paso, muestrea las columnas configuradas como entradas con \textit{pull-up} interno. Cuando una tecla se presiona, se establece un camino de conducción que fuerza a nivel bajo la columna correspondiente, permitiendo identificar la pareja (fila, columna) y mapearla al carácter asociado (\texttt{0 a 9}, \texttt{A a D}, \texttt{*}, \texttt{\#}). Este procedimiento se complementa con retardos breves para atenuar el efecto de rebote mecánico (\textit{debouncing}). La disposición eléctrica y el mapeo de pines siguen el módulo de teclado 4×4 utilizado \cite{keypad_4x4_okystar}.

\subsubsection{Visualización: LCD 16×2 con interfaz I\textsuperscript{2}C}
La pantalla LCD se controla en modo de 4 bits a través de un \textit{backpack} basado en el expansor de E/S PCF8574, que traslada la comunicación I\textsuperscript{2}C (líneas SDA/SCL) a señales paralelas (\texttt{RS}, \texttt{E}, \texttt{D4 a D7} y control de backlight). A nivel de bus, el ATmega328P opera como maestro TWI e inicia/termina transacciones mediante condiciones \textit{START}/\textit{STOP}, escribiendo bytes en la dirección del expansor. Sobre esa base, el software implementa las primitivas de inicialización del LCD (función, \textit{display on/off}, \textit{clear}, \textit{entry mode}) y las rutinas de posicionamiento y envío de datos/caracteres. La interfaz seleccionada reduce el número de pines GPIO necesarios y simplifica el cableado \cite{lcd_16x2_i2c_datasheet}.

\subsubsection{Almacenamiento no volátil del PIN (EEPROM)}
El PIN de usuario (longitud configurable entre 4 y 6 dígitos) se guarda en la EEPROM interna, junto con su longitud. En el arranque, si no hay un PIN válido, el firmware inicializa un valor por defecto y normaliza la estructura de almacenamiento. La EEPROM permite escritura/lectura byte a byte, con funciones de actualización que evitan ciclos de borrado innecesarios, prolongando la vida útil de la memoria \cite{atmega328p_datasheet}.

\subsubsection{Gestión de estados y seguridad}
El flujo lógico se organiza como una máquina de estados finitos:
\begin{itemize}
    \item \textbf{Modo normal}: ingreso del PIN y validación.
    \item \textbf{Cambio de PIN}: secuencia guiada en tres pasos: verificación del PIN actual, ingreso del nuevo PIN y confirmación (comando \texttt{C} para iniciar; \texttt{A} para confirmar; \texttt{B} para limpiar).
    \item \textbf{Bloqueo}: tras tres intentos fallidos consecutivos, el sistema ingresa en estado de alarma/bloqueo. La salida requiere la \textit{llave maestra} (\texttt{D}), lo que restablece el contador de intentos y retorna a modo normal.
\end{itemize}
Adicionalmente, se implementan validaciones de formato (por ejemplo, longitud mínima de 4 dígitos). Las decisiones de diseño (límite de intentos, clave maestra, confirmación doble del nuevo PIN) elevan la robustez frente a errores de ingreso y mitigaciones de prueba y error.

\subsubsection{Señalización: LEDs y Buzzer}
La interacción con el usuario se refuerza mediante señales visuales y acústicas. El \textbf{LED verde} y un patrón de tres pulsos cortos del \textbf{buzzer} indican validación correcta; el \textbf{LED rojo} junto con un pulso sostenido del buzzer señalan error de PIN o formatos inválidos. En estado de bloqueo, se alternan periodos de activación/desactivación de LED rojo y buzzer hasta la intervención con la tecla maestra. El buzzer piezoeléctrico empleado funciona como transductor binario (encendido/apagado) para retroalimentación breve, diferenciándose del uso tonal continuo aplicado en el ejercicio del piano \cite{buzzer_emx7t05sp_datasheet}.

\subsubsection{Consideraciones temporales y \textit{debouncing}}
La temporización se apoya en retardos de corta duración para estabilizar lecturas del teclado y construir patrones de señalización perceptibles (confirmaciones, alarmas). En sistemas embebidos, el \textit{debouncing} por software con retardos y verificación consecutiva de estado es una estrategia suficiente para teclados de baja tasa de eventos; no obstante, para escalabilidad se podrían considerar interrupciones por cambio de pin, filtros digitales o máquinas de tiempo dedicadas.

\subsubsection{Síntesis}
En conjunto, la cerradura digital ilustra la integración de periféricos síncronos (I\textsuperscript{2}C/TWI) y asíncronos (GPIO escaneados), memoria no volátil (EEPROM) y una máquina de estados que implementa políticas de seguridad (longitud mínima, límite de intentos, clave maestra). El diseño resultante evidencia la capacidad del ATmega328P para articular adquisición, procesamiento y respuesta en tiempo real en un entorno embebido con interfaz hombre–máquina clara y consistente.

