\section{Marco Teórico}

\subsection{Plotter}

\subsection{Sistema de Control de Temperatura}

\subsection{Control de motor}

El presente experimento tiene como objetivo implementar un control proporcional de velocidad y dirección en un motor de corriente continua (\textit{DC}).  
Este tipo de control se basa en ajustar el ciclo de trabajo (\textit{duty cycle}) de una señal PWM (\textit{Pulse Width Modulation}) en función de la diferencia entre un valor de referencia y la retroalimentación medida, generando así un comportamiento lineal y estable en la respuesta del motor \cite{sparkfun_pwm_tutorial}.

Para lograrlo, se utilizó un \textbf{puente H L298N}, que permite invertir la polaridad del motor mediante dos entradas digitales de control, posibilitando el giro en ambos sentidos \cite{st_l298n_datasheet}.  
El puente H se alimentó con \SI{5}{\volt}, mientras que las señales de control provinieron directamente del microcontrolador \textbf{ATmega328P} \cite{microchip_atmega328p_datasheet}.  
El pin \texttt{ENA} del L298N se controló con una señal PWM generada por el temporizador interno \texttt{Timer1}.

El \texttt{Timer1} fue configurado en modo \textit{Fast PWM} de 8~bits, con salida no invertida sobre el pin \texttt{OC1A} (D9) y prescaler igual a 1, alcanzando una frecuencia de conmutación de aproximadamente \SI{62.5}{\kilo\hertz}.  
Este modo permite generar un ciclo de trabajo variable entre 0 y 255, directamente proporcional al valor calculado por el control proporcional en el código.

El sistema empleó dos potenciómetros conectados a las entradas analógicas \texttt{A0} (referencia) y \texttt{A1} (realimentación), cuya lectura se realizó mediante el conversor analógico–digital (ADC) de 10~bits del microcontrolador \cite{microchip_atmega328p_datasheet}.  
La diferencia entre ambas señales (\( e = V_{\text{ref}} - V_{\text{act}} \)) determina la dirección de giro y la magnitud del PWM aplicado.  
Para evitar oscilaciones cercanas al punto de equilibrio, se definió una zona muerta de ±10 unidades ADC.  
De este modo, cuando la diferencia entre potenciómetros se mantiene dentro de ese rango, el motor permanece detenido y ambos LEDs indicadores se apagan.

El valor mínimo de PWM efectivo fue calibrado en 180 (\(\approx 70\%\) del ciclo de trabajo), ya que valores inferiores no lograban vencer la inercia del motor bajo carga.
El sistema se comportó de forma estable, respondiendo proporcionalmente a los cambios de referencia y deteniéndose al alcanzar la coincidencia entre ambas señales.

\subsection{Matriz RGB con joystick}

Este experimento tuvo como objetivo implementar el control de una matriz de LEDs RGB tipo \textbf{WS2812B} de 8×8, utilizando un \textbf{joystick analógico} para desplazar un píxel activo en la pantalla.  
El microcontrolador \textbf{ATmega328P} genera la señal digital codificada a una frecuencia de \SI{800}{\kilo\hertz}, respetando el protocolo de transmisión GRB (Green–Red–Blue) característico del WS2812B \cite{worldsemi_ws2812b_datasheet}.  
Este protocolo requiere una temporización precisa en el orden de cientos de nanosegundos, lo que se logró mediante retardos calibrados y la generación manual de pulsos de nivel lógico en el código.

El joystick utilizado es del tipo analógico–digital, compuesto por dos potenciómetros ortogonales (ejes X e Y) y un pulsador central (SW), permitiendo leer desplazamientos horizontales, verticales y acciones de selección \cite{sparkfun_joystick_tutorial}.  
Los ejes se conectaron a las entradas analógicas \texttt{A0} y \texttt{A1}, mientras que el pulsador se conectó a un pin digital configurado como entrada con resistencia de \textit{pull-up} interna.

Durante el desarrollo se consideró inicialmente implementar un mapeo matricial continuo, donde las coordenadas del LED activo dependieran de un cálculo analógico proporcional.  
Sin embargo, este enfoque resultó complejo de calibrar y sensible al ruido, por lo que se optó finalmente por un control basado en condiciones discretas, que permitió un funcionamiento más estable y predecible.  
Además, se incorporó una zona muerta en el eje central para evitar desplazamientos involuntarios del LED, y un retardo (\textit{cooldown}) entre movimientos para suavizar la respuesta visual.

El resultado fue un sistema fluido, capaz de representar el movimiento del joystick con buena estabilidad y cambio de color del LED activo mediante el pulsador.  
La comprensión del protocolo WS2812B y la sincronización precisa de la señal permitieron reforzar los conocimientos sobre control digital de periféricos de alta velocidad.

\subsection{Cerradura RFID}

El objetivo de esta práctica fue desarrollar una cerradura electrónica que gestionara el acceso mediante tarjetas \textbf{RFID} del tipo \textbf{MIFARE 1K 13.56 MHz}, utilizando el lector \textbf{RC522} en conjunto con el microcontrolador \textbf{ATmega328P}.  
El sistema permite registrar y eliminar tarjetas, validar accesos y visualizar los estados mediante una pantalla LCD I2C y LEDs indicadores.

El lector RC522 se comunica con el microcontrolador a través del bus SPI (\textit{Serial Peripheral Interface}), empleando una velocidad de reloj de \SI{2}{\mega\hertz} y operando en modo maestro \cite{nxp_mfrc522_datasheet}.  
Las señales \texttt{SDA}, \texttt{SCK}, \texttt{MOSI}, \texttt{MISO} y \texttt{RST} fueron conectadas a los pines digitales \texttt{D10}, \texttt{D13}, \texttt{D11}, \texttt{D12} y \texttt{D9}, respectivamente.  
La pantalla LCD de 16×2 caracteres se controló mediante un expansor \textbf{PCF8574} conectado al bus I2C, utilizando las líneas \texttt{SDA → A4} y \texttt{SCL → A5} \cite{nexperia_pcf8574_datasheet}.  
El LED verde y el LED rojo indicaron los estados de validación de acceso, mientras que un pulsador externo activó el modo de programación.

La lógica del sistema se implementó mediante un autómata de estados finitos (FSM), compuesto por las siguientes etapas:  
inicio (espera de tarjeta), lectura del UID, verificación, acceso permitido, acceso denegado y modo programación.  
En este último estado, el sistema permite dar de alta o baja tarjetas mediante la detección del pulsador.  
Los UID autorizados se almacenaron en la memoria EEPROM interna del microcontrolador, con un tamaño máximo de 64 registros de 4 bytes cada uno \cite{microchip_atmega328p_datasheet}.

Durante las pruebas se observó que la lectura del RC522 era más sensible al tiempo de respuesta en modo de programación, lo cual se mitigó ajustando los retardos entre lecturas y el control de la bandera de detección.  
El sistema final demostró una lectura estable, almacenamiento persistente y una interfaz de usuario clara, validando el correcto funcionamiento conjunto de los periféricos SPI, I2C y UART en una misma arquitectura embebida.